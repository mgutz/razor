package razor

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"text/template"
)

var razorNamespace = `"github.com/mgutz/razor"`
var genericArgRe = regexp.MustCompile(`\(([^,\)]+)`)
var doNotEdit = "// DO NOT EDIT! Auto-generated by github.com/mgutz/razor\n\n"

//------------------------------ Compiler ------------------------------ //
const (
	CMKP = iota
	CBLK
	CSTAT
)

func getValStr(e interface{}) string {
	switch v := e.(type) {
	case *Ast:
		return v.TagName
	case Token:
		if !(v.Type == AT || v.Type == AT_COLON) {
			return v.Text
		}
		return ""
	default:
		panic(e)
	}
}

type Part struct {
	ptype int
	value string
}

type renderInfo struct {
	sync.Mutex
	dirBasenames map[string][]string
}

// renderData tracks all generated non-layout templates to create
// Render(path, model) in razor_render.go
var renderData = renderInfo{dirBasenames: make(map[string][]string)}

type Compiler struct {
	ast                 *Ast
	buf                 string //the final result
	layout              string
	firstBLK            int
	params              string
	parts               []Part
	imports             map[string]bool
	dir                 string
	pkg                 string
	baseName            string
	funcName            string
	result              string
	defineRenderSection bool
	defineRenderBody    bool
	defineApp           bool
	dataAssertionType   string
	isLayout            bool
}

func (self *Compiler) addPart(part Part) {
	if len(self.parts) == 0 {
		self.parts = append(self.parts, part)
		return
	}
	last := &self.parts[len(self.parts)-1]
	if last.ptype == part.ptype {
		last.value += part.value
	} else {
		self.parts = append(self.parts, part)
	}
}

func (self *Compiler) genPart() {
	res := ""
	for _, p := range self.parts {
		if p.ptype == CMKP && p.value != "" {
			// do some escapings
			p.value = strings.Replace(p.value, `\n`, `\\n`, -1)
			p.value = strings.Replace(p.value, "\n", `\n`, -1)
			p.value = strings.Replace(p.value, `"`, `\"`, -1)
			for strings.HasSuffix(p.value, "\\n") {
				p.value = p.value[:len(p.value)-2]
			}
			if p.value != "\\n" && p.value != "" {
				res += "__buffer.WriteString(\"" + p.value + "\")\n"
			}
		} else if p.ptype == CBLK {
			if strings.HasPrefix(p.value, "{") &&
				strings.HasSuffix(p.value, "}") {
				p.value = p.value[1 : len(p.value)-2]
			}
			res += p.value + "\n"
		} else {
			res += p.value
		}
	}
	self.buf = res
}

func makeCompiler(ast *Ast, input string) *Compiler {
	dir := filepath.Dir(input)
	pkg := filepath.Base(dir)
	baseName := strings.Replace(filepath.Base(input), gz_extension, "", 1)
	funcName := Capitalize(baseName)
	cp := &Compiler{
		ast:      ast,
		buf:      "",
		firstBLK: 0,
		params:   "()",
		parts:    []Part{},
		imports:  map[string]bool{},
		dir:      dir,
		pkg:      pkg,
		baseName: baseName,
		funcName: funcName,
		isLayout: false,
	}
	return cp
}

func (cp *Compiler) visitBLK(child interface{}, ast *Ast) {
	blk := getValStr(child)
	cp.addPart(Part{CBLK, blk})
}

func (cp *Compiler) visitMKP(child interface{}, ast *Ast) {
	cp.addPart(Part{CMKP, getValStr(child)})
}

// First block contains imports and parameters, specific action for layout,
// NOTE, layout have some conventions.
func (cp *Compiler) visitFirstBLK(blk *Ast) {
	pre := cp.buf
	cp.buf = ""

	first := ""
	backup := cp.parts
	cp.parts = []Part{}
	cp.visitAst(blk)
	cp.genPart()
	first, cp.buf = cp.buf, pre
	cp.parts = backup

	isImport := false
	lines := strings.SplitN(first, "\n", -1)
	for _, l := range lines {
		l = strings.TrimSpace(l)
		if strings.HasPrefix(l, "import") || strings.HasPrefix(l, "+import") {
			isImport = true
			continue
		}
		if l == ")" {
			isImport = false
			continue
		}

		if isImport {
			cp.imports[l] = true
		} else if strings.HasPrefix(l, "+params") {
			vname := l[7:]
			if Options.InterfaceArg {
				matches := genericArgRe.FindStringSubmatch(vname)
				if len(matches) == 2 {
					firstArg := matches[1]
					parts := strings.Split(firstArg, " ")
					name, typ := parts[0], parts[1]
					if typ != "interface{}" {
						cp.dataAssertionType = name + " := __data.(" + typ + ")\n"
						vname = strings.Replace(vname, firstArg, "__data interface{}", 1)
					}
				}
			}
			cp.isLayout = strings.Contains(vname, "...)")
			cp.params = strings.Replace(vname, "...)", "__body *razor.SafeBuffer, __sections *razor.Sections)", 1)
		} else if strings.HasPrefix(l, "+extends ") {
			vname := l[9:]
			cp.result = vname
		} else if strings.HasPrefix(l, "+return ") {
			vname := l[8:]
			cp.result = vname
		} else if l != "" {
			cp.addPart(Part{CSTAT, l + "\n"})
		}
	}

}

func (cp *Compiler) visitExp(child interface{}, parent *Ast, idx int, isHomo bool) {
	start := ""
	end := ""
	ppNotExp := true
	ppChildCnt := len(parent.Children)
	if parent.Parent != nil && parent.Parent.Mode == EXP {
		ppNotExp = false
	}
	val := getValStr(child)

	if ppNotExp && idx == 0 {
		start = "__buffer.WriteSafe(" + start
	}
	if ppNotExp && idx == ppChildCnt-1 {
		end += ")\n"
	}

	v := start
	if val == "raw" {
		v += end
	} else {
		v += val + end
	}
	cp.addPart(Part{CSTAT, v})
}

func (cp *Compiler) visitAst(ast *Ast) {
	cp.imports[razorNamespace] = true

	switch ast.Mode {
	case MKP:
		cp.firstBLK = 1
		for _, c := range ast.Children {
			if _, ok := c.(Token); ok {
				cp.visitMKP(c, ast)
			} else {
				cp.visitAst(c.(*Ast))
			}
		}
	case BLK:
		if cp.firstBLK == 0 {
			cp.firstBLK = 1
			cp.visitFirstBLK(ast)
		} else {
			for _, c := range ast.Children {
				if _, ok := c.(Token); ok {
					cp.visitBLK(c, ast)
				} else {
					cp.visitAst(c.(*Ast))
				}
			}
		}
	case EXP:
		cp.firstBLK = 1
		nonExp := ast.hasNonExp()
		for i, c := range ast.Children {
			if _, ok := c.(Token); ok {
				cp.visitExp(c, ast, i, !nonExp)
			} else {
				cp.visitAst(c.(*Ast))
			}
		}
	case PRG:
		for _, c := range ast.Children {
			cp.visitAst(c.(*Ast))
		}
	}
}

// TODO, this is dirty now
func (cp *Compiler) processLayout() {
	lines := strings.SplitN(cp.buf, "\n", -1)
	out := ""
	sections := []string{}
	scope := 0
	for _, l := range lines {
		l = strings.TrimSpace(l)
		if strings.HasPrefix(l, "section") && strings.HasSuffix(l, "{") {
			name := l
			name = strings.TrimSpace(name[7 : len(name)-1])
			out += "\n__" + name + " := func() *razor.SafeBuffer {\n"
			out += "__buffer := razor.NewSafeBuffer()\n"
			scope = 1
			sections = append(sections, name)
		} else if scope > 0 {
			if strings.HasSuffix(l, "{") {
				scope++
			} else if strings.HasSuffix(l, "}") {
				scope--
			}
			if scope == 0 {
				out += "return __buffer\n}\n"
				//scope = 0
			} else {
				out += l + "\n"
			}
		} else {
			out += l + "\n"
		}
	}
	cp.buf = out

	if cp.result != "" {
		var result string
		if len(sections) > 0 {
			cp.buf += "__sections := make(razor.Sections)\n"
			for _, section := range sections {
				cp.buf += fmt.Sprintf("__sections[\"%s\"] = __%s()\n", section, section)
			}
			result = strings.Replace(cp.result, "...)", "__buffer, &__sections)", 1)
		} else {
			result = strings.Replace(cp.result, "...)", "__buffer, nil)", 1)
		}
		cp.buf += "__buffer = " + result
	}
	cp.buf += "\n return __buffer\n}\n"
}

func (cp *Compiler) visit() {
	cp.visitAst(cp.ast)
	cp.genPart()

	pack := cp.pkg
	fun := cp.funcName

	//cp.imports[`"bytes"`] = true
	head := NewSafeBufferString(doNotEdit)
	head.WriteString("package " + pack + "\n import (\n")
	for k := range cp.imports {
		head.WriteString(k + "\n")
	}

	// adds comment to appease golint
	head.WriteString("\n)\n// " + fun + " is generated\nfunc " + fun + cp.params)
	head.WriteString(` *razor.SafeBuffer {
		__buffer := razor.NewSafeBuffer()
	`)
	if Options.InterfaceArg && cp.dataAssertionType != "" {
		head.WriteString(cp.dataAssertionType)
	}
	if cp.defineApp {
		head.WriteString(`
			App := razor.App
		`)
	}
	if cp.defineRenderBody {
		head.WriteString(`
			RenderBody := func() *razor.SafeBuffer {
				return __body
			}
		`)
	}
	if cp.defineRenderSection {
		head.WriteString(`
			RenderSection := func(section string, required ...bool) *razor.SafeBuffer {
				sections := *__sections
				text := sections[section]
				isRequired := len(required) == 1 && required[0]
				if text == nil && isRequired {
					return razor.NewSafeBufferString("<div style='color:white; background-color: red'>SECTION " + section + " is required!<div>")
				}
				return text
			}
		`)
	}
	head.WriteString(cp.buf)
	cp.buf = head.String()
	cp.processLayout()
}

func run(path string) (*Compiler, error) {
	content, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	text := string(content)
	lex := &Lexer{text, Tests}
	res, err := lex.Scan()
	if err != nil {
		return nil, err
	}

	//DEBUG
	if Options.Debug {
		fmt.Println("------------------- TOKEN START -----------------")
		for _, elem := range res {
			elem.P()
		}
		fmt.Println("--------------------- TOKEN END -----------------\n")
	}

	parser := &Parser{&Ast{}, nil, res, []Token{}, false, UNK}
	err = parser.Run()
	if err != nil {
		fmt.Println(err)
		os.Exit(2)
	}

	//DEBUG
	if Options.Debug {
		fmt.Println("--------------------- AST START -----------------")
		parser.ast.debug(0, 20)
		fmt.Println("--------------------- AST END -----------------\n")
		if parser.ast.Mode != PRG {
			panic("TYPE")
		}
	}
	cp := makeCompiler(parser.ast, path)
	cp.defineApp = strings.Contains(text, "@App")
	cp.defineRenderBody = strings.Contains(text, "@RenderBody")
	cp.defineRenderSection = strings.Contains(text, "@RenderSection")
	cp.visit()
	return cp, nil
}

func generate(path string, output string) error {
	cp, err := run(path)
	if !cp.isLayout && Options.InterfaceArg {
		renderData.Lock()
		renderData.dirBasenames[cp.dir] = append(renderData.dirBasenames[cp.dir], cp.baseName)
		renderData.Unlock()
	}
	if err != nil || cp == nil {
		panic(err)
	}
	return writeGoFile(output, []byte(cp.buf))
}

func writeGoFile(filename string, buf []byte) error {
	err := ioutil.WriteFile(filename, buf, 0644)
	if err != nil {
		return err
	}
	cmd := exec.Command("gofmt", "-s", "-w", filename)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		fmt.Println("gofmt: ", err)
		return err
	}
	if Options.Debug {
		content, _ := ioutil.ReadFile(filename)
		fmt.Println(string(content))
	}
	return nil
}

//------------------------------ API ------------------------------
const (
	go_extension = ".go"
	gz_extension = ".go.html"
)

// Generate from input to output file,
func GenFile(input string, output string) error {
	//fmt.Printf("input=%s output=%s\n", input, output)
	outdir := filepath.Dir(output)
	if !exists(outdir) {
		os.MkdirAll(outdir, 0775)
	}
	return generate(input, output)
}

// Generate from directory to directory, Find all the files with extension
// of .go.html and generate it into target dir.
func GenFolder(indir string, outdir string) (err error) {
	if !exists(indir) {
		return errors.New("Input directory does not exsits")
	} else {
		if err != nil {
			return err
		}
	}
	//Make it
	if !exists(outdir) {
		os.MkdirAll(outdir, 0775)
	}

	incdir_abs, _ := filepath.Abs(indir)
	outdir_abs, _ := filepath.Abs(outdir)

	paths := []string{}

	visit := func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() {
			//Just do file with extension .go.html
			if !strings.HasSuffix(path, gz_extension) {
				return nil
			}
			filename := filepath.Base(path)
			if strings.HasPrefix(filename, ".#") {
				return nil
			}
			paths = append(paths, path)
		}
		return nil
	}

	fun := func(path string, res chan<- string) {
		//adjust with the abs path, so that we keep the same directory hierarchy
		input, _ := filepath.Abs(path)
		output := strings.Replace(input, incdir_abs, outdir_abs, 1)
		output = strings.Replace(output, gz_extension, go_extension, -1)
		err := GenFile(path, output)
		if err != nil {
			res <- fmt.Sprintf("%s -> %s", path, output)
			os.Exit(2)
		}
		res <- fmt.Sprintf("%s -> %s", path, output)
	}

	err = filepath.Walk(indir, visit)
	runtime.GOMAXPROCS(runtime.NumCPU())
	result := make(chan string, len(paths))

	for w := 0; w < len(paths); w++ {
		go fun(paths[w], result)
	}
	for i := 0; i < len(paths); i++ {
		<-result
	}

	if Options.InterfaceArg {
		writeRazorRenderGoFile()
	}

	return
}

func writeRazorRenderGoFile() {
	for dir, basenames := range renderData.dirBasenames {
		model := struct {
			Pkg   string
			Funcs map[string]string
		}{
			Pkg:   filepath.Base(dir),
			Funcs: make(map[string]string),
		}
		for _, basename := range basenames {
			model.Funcs[basename] = Capitalize(basename)
		}

		tmpl, err := template.New("test").Parse(doNotEdit + razorRenderTemplate)
		if err != nil {
			fmt.Errorf("Could not compile template razorRenderTemplate")
		}
		var buf bytes.Buffer
		tmpl.Execute(&buf, model)
		err = writeGoFile(filepath.Join(dir, "razor_render.go"), buf.Bytes())
		if err != nil {
			fmt.Errorf("Could not write razor_render.go\n%v\n", err)
		}
	}
}

var razorRenderTemplate = `
package {{.Pkg}}

import (
	"github.com/mgutz/razor"
)

// Render returns the generated template function for a given path.
// Layouts are not included.
func Render(path string, model interface{}) *razor.SafeBuffer {
	switch path {
	default:
		return razor.NewSafeBufferString("Invalid template: " + path)
	{{ range $key, $name := .Funcs }}
	case "{{ $key }}":
		return {{ $name }}(model)
	{{ end }}
	}
}
`
